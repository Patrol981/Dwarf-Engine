using Vortice.Vulkan;
using static Vortice.Vulkan.Vulkan;

namespace Dwarf.Engine.Shaders;
public unsafe class Shader : IDisposable {

  public readonly VkPipelineLayout PipelineLayout;
  private readonly GraphicsDevice _graphicsDevice;

  public Shader(GraphicsDevice graphicsDevice, string vertex, string fragment) {
    _graphicsDevice = graphicsDevice;


    #region Pipeline Layout
    CreateShaderModule(_graphicsDevice, vertex, out var vertexShader);
    CreateShaderModule(_graphicsDevice, vertex, out var fragmetShader);

    VkString entryPoint = new("main");
    VkPipelineShaderStageCreateInfo* shaderStages = stackalloc VkPipelineShaderStageCreateInfo[2];

    //vertex
    shaderStages[0].sType = VkStructureType.PipelineShaderStageCreateInfo;
    shaderStages[0].stage = VkShaderStageFlags.Vertex;
    shaderStages[0].module = vertexShader;
    shaderStages[0].pName = entryPoint;

    //fragment
    shaderStages[1].sType = VkStructureType.PipelineShaderStageCreateInfo;
    shaderStages[1].stage = VkShaderStageFlags.Fragment;
    shaderStages[1].module = fragmetShader;
    shaderStages[1].pName = entryPoint;

    var dynamicStates = stackalloc VkDynamicState[2];
    dynamicStates[0] = VkDynamicState.Viewport;
    dynamicStates[1] = VkDynamicState.Scissor;

    var dynamicState = new VkPipelineDynamicStateCreateInfo {
      sType = VkStructureType.PipelineDynamicStateCreateInfo,
      dynamicStateCount = 2,
      pDynamicStates = dynamicStates
    };

    var vertexInputInfo = new VkPipelineVertexInputStateCreateInfo {
      sType = VkStructureType.PipelineVertexInputStateCreateInfo,
      vertexBindingDescriptionCount = 0,
      pVertexBindingDescriptions = null,
      vertexAttributeDescriptionCount = 0,
      pVertexAttributeDescriptions = null
    };

    var inputAssemble = new VkPipelineInputAssemblyStateCreateInfo {
      sType = VkStructureType.PipelineInputAssemblyStateCreateInfo,
      topology = VkPrimitiveTopology.TriangleList,
      primitiveRestartEnable = false
    };

    var scissor = new VkRect2D {
      offset = new VkOffset2D(0, 0),
      extent = _graphicsDevice.Swapchain.Extent2D
    };

    var viewport = new VkViewport {
      x = 0.0f,
      y = 0.0f,
      width = (float)_graphicsDevice.Swapchain.Extent2D.width,
      height = (float)_graphicsDevice.Swapchain.Extent2D.height,
      minDepth = 0.0f,
      maxDepth = 1.0f
    };

    var viewportState = new VkPipelineViewportStateCreateInfo {
      sType = VkStructureType.PipelineViewportStateCreateInfo,
      viewportCount = 1,
      scissorCount = 1,
      pViewports = &viewport,
      pScissors = &scissor
    };

    var rasterizer = new VkPipelineRasterizationStateCreateInfo {
      sType = VkStructureType.PipelineRasterizationStateCreateInfo,
      depthClampEnable = false,
      rasterizerDiscardEnable = false,
      polygonMode = VkPolygonMode.Fill,
      lineWidth = 1.0f,
      cullMode = VkCullModeFlags.Back,
      frontFace = VkFrontFace.Clockwise,
      depthBiasEnable = false,
      depthBiasConstantFactor = 0.0f,
      depthBiasClamp = 0.0f,
      depthBiasSlopeFactor = 0.0f
    };

    var multisampling = new VkPipelineMultisampleStateCreateInfo {
      sType = VkStructureType.PipelineMultisampleStateCreateInfo,
      sampleShadingEnable = false,
      rasterizationSamples = VkSampleCountFlags.Count1,
      minSampleShading = 1.0f,
      pSampleMask = null,
      alphaToCoverageEnable = false,
      alphaToOneEnable = false
    };

    var colorBlendAttachment = new VkPipelineColorBlendAttachmentState {
      colorWriteMask = VkColorComponentFlags.R | VkColorComponentFlags.B | VkColorComponentFlags.B | VkColorComponentFlags.A,
      blendEnable = false,
      srcColorBlendFactor = VkBlendFactor.One,
      dstColorBlendFactor = VkBlendFactor.Zero,
      colorBlendOp = VkBlendOp.Add,
      srcAlphaBlendFactor = VkBlendFactor.One,
      dstAlphaBlendFactor = VkBlendFactor.Zero,
      alphaBlendOp = VkBlendOp.Add
    };


    var blendConstants = stackalloc float[4];
    blendConstants[0] = 0.0f;
    blendConstants[1] = 0.0f;
    blendConstants[2] = 0.0f;
    blendConstants[3] = 0.0f;
    var colorBlend = new VkPipelineColorBlendStateCreateInfo {
      sType = VkStructureType.PipelineColorBlendStateCreateInfo,
      logicOpEnable = false,
      logicOp = VkLogicOp.Copy,
      attachmentCount = 1,
      pAttachments = &colorBlendAttachment
    };

    var pipelineInfo = new VkPipelineLayoutCreateInfo {
      sType = VkStructureType.PipelineLayoutCreateInfo,
      setLayoutCount = 0,
      pushConstantRangeCount = 0
    };

    vkCreatePipelineLayout(
      _graphicsDevice.VkLogicalDevice,
      &pipelineInfo,
      null,
      out PipelineLayout
    );

    vkDestroyShaderModule(_graphicsDevice.VkLogicalDevice, vertexShader, null);
    vkDestroyShaderModule(_graphicsDevice.VkLogicalDevice, fragmetShader, null);

    #endregion

    var pipelineCreateInfo = new VkGraphicsPipelineCreateInfo {
      sType = VkStructureType.GraphicsPipelineCreateInfo,
      stageCount = 2,
      pStages = shaderStages,
      pVertexInputState = &vertexInputInfo,
      pInputAssemblyState = &inputAssemble,
      pViewportState = &viewportState,
      pRasterizationState = &rasterizer,
      pMultisampleState = &multisampling,
      pDepthStencilState = null,
      pColorBlendState = &colorBlend,
      pDynamicState = &dynamicState,
      layout = PipelineLayout,
      renderPass = _graphicsDevice.Swapchain.RenderPass,
      subpass = 0,
      basePipelineHandle = VkPipeline.Null,
      basePipelineIndex = -1
    };

    vkCreateGraphicsPipeline(
      _graphicsDevice.VkLogicalDevice,
      pipelineCreateInfo,
      out _graphicsDevice.Swapchain.Pipeline
    );
  }

  public static void CreateShaderModule(GraphicsDevice graphicsDevice, string name, out VkShaderModule shaderModule) {
    var path = Path.Combine(AppContext.BaseDirectory, "CompiledShaders", $"{name}.spv");
    byte[] vertexBytecode = File.ReadAllBytes(path);
    graphicsDevice.CreateShaderModule(vertexBytecode, out shaderModule).CheckResult();
  }

  public void Dispose() {
    vkDestroyPipelineLayout(_graphicsDevice.VkLogicalDevice, PipelineLayout, null);
  }
}